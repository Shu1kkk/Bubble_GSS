/*************************************************
 * SheetTabTools v2.1: タブ色マーキング＆整列＆一括削除
 * - 赤タブ … 手動マーキング（残す）
 * - 青タブ … 自動生成シート（PivotA/PivotB/アップロード履歴）
 * - 左詰めは 赤 → 青 の順
 * - 削除は 青 ＆ 色なし を対象（赤や他色は残す）
 *************************************************/
const TAB = {
  RED : '#ea4335',
  BLUE: '#1a73e8',
  REDS : ['#ea4335','#ff0000','#d93025','#e53935','#f44336'].map(s=>s.toLowerCase()),
  BLUES: ['#1a73e8','#4285f4','#3367d6','#1976d2','#1e88e5'].map(s=>s.toLowerCase()),
  PROTECT_ALWAYS: ['_time_trigger_log', '_time_trigger_reserve'] // 削除対象から常に除外
};

function _hex(sh){ const c = sh.getTabColor && sh.getTabColor(); return c ? String(c).toLowerCase() : ''; }
function _isRed(sh){
  const h=_hex(sh); if(!h) return false;
  if (TAB.REDS.includes(h)) return true;
  const m=/^#?([0-9a-f]{6})$/.exec(h); if(!m) return false;
  const n=parseInt(m[1],16), r=(n>>16)&255, g=(n>>8)&255, b=n&255;
  return (r>=200 && g<=90 && b<=90);
}
function _isBlue(sh){
  const h=_hex(sh); if(!h) return false;
  if (TAB.BLUES.includes(h)) return true;
  const m=/^#?([0-9a-f]{6})$/.exec(h); if(!m) return false;
  const n=parseInt(m[1],16), r=(n>>16)&255, g=(n>>8)&255, b=n&255;
  return (b>=170 && r<=120 && g<=160);
}

/** 生成シート名を青でマーキング（存在すれば色付けのみ） */
function markAutoGeneratedSheetsBlue_(){
  const ss = SpreadsheetApp.getActive();
  const NAMES = [
    'PivotA_auto','pibotA_auto',   // 念のため両対応
    'PivotB_auto','pivotB_auto',   // 念のため両対応
    'アップロード履歴'
  ];
  const done = [];
  for (const name of NAMES){
    const sh = ss.getSheetByName(name);
    if (sh){ sh.setTabColor(TAB.BLUE); done.push(name); }
  }
  ss.toast(`青マーキング: ${done.length} シート`);
  return done;
}

/** シートを所定の位置へ移動（非表示は一時表示→移動→元に戻す） */
function moveSheetToPosition_(ss, sh, posIndex) {
  const wasHidden = (typeof sh.isSheetHidden === 'function') ? sh.isSheetHidden() : false;
  const prev = ss.getActiveSheet();
  try {
    if (wasHidden) sh.showSheet();
    ss.setActiveSheet(sh);
    ss.moveActiveSheet(posIndex);     // 1始まり
  } finally {
    if (prev && prev !== sh) ss.setActiveSheet(prev, true);
    if (wasHidden) sh.hideSheet();
  }
}

/** 左詰め：赤グループ→青グループの順に左へ寄せる */
function moveMarkedSheetsToLeft_(){
  const ss = SpreadsheetApp.getActive();

  // 念のため既存の生成シートにも青を付与
  if (typeof markAutoGeneratedSheetsBlue_ === 'function') markAutoGeneratedSheetsBlue_();

  const sheets = ss.getSheets();

  // 優先表示順（名前一致で優先）
  const PR_RED  = ['PivotA_auto','pibotA_auto','PivotB_auto','pivotB_auto','アップロード履歴'];
  const PR_BLUE = ['PivotA_auto','pibotA_auto','PivotB_auto','pivotB_auto','アップロード履歴'];

  const reds  = sheets.filter(_isRed);
  const blues = sheets.filter(s => !_isRed(s) && _isBlue(s));

  const idxOf = sh => (typeof sh.getIndex === 'function') ? sh.getIndex() : 9999;

  reds.sort((a,b)=>{
    const ai = PR_RED.indexOf(a.getName()),  bi = PR_RED.indexOf(b.getName());
    const aa = (ai === -1 ? 999 : ai),       bb = (bi === -1 ? 999 : bi);
    return (aa !== bb) ? aa - bb : idxOf(a) - idxOf(b);
  });
  blues.sort((a,b)=>{
    const ai = PR_BLUE.indexOf(a.getName()), bi = PR_BLUE.indexOf(b.getName());
    const aa = (ai === -1 ? 999 : ai),       bb = (bi === -1 ? 999 : bi);
    return (aa !== bb) ? aa - bb : idxOf(a) - idxOf(b);
  });

  let pos = 1;
  reds.forEach(sh  => moveSheetToPosition_(ss, sh, pos++));
  blues.forEach(sh => moveSheetToPosition_(ss, sh, pos++));

  ss.toast(`左詰め：赤 ${reds.length} → 青 ${blues.length}`);
}

/** メニュー：シートタブ整理 → シート左詰め（赤→青） */
function buildMenu_SheetTabTools_(){
  SpreadsheetApp.getUi()
    .createMenu('シートタブ整理')
    .addItem('シート左詰め（赤→青）', 'moveMarkedSheetsToLeft_')
    .addToUi();
}

/** 削除：青タブ＆色なし（赤・他色・保護シートは残す） */
function deleteBlueAndColorlessSheets_(){
  const ui = SpreadsheetApp.getUi();
  const ss = SpreadsheetApp.getActive();

  const all = ss.getSheets();
  const deletable = [];
  const skipped   = [];

  for (const sh of all){
    const name = sh.getName();
    if (TAB.PROTECT_ALWAYS.includes(name) || _isRed(sh)) { skipped.push(name); continue; }
    const colored = !!_hex(sh);
    if (_isBlue(sh) || !colored) { deletable.push(sh); } else { skipped.push(name); }
  }

  if (deletable.length === 0) {
    ss.toast('削除対象なし（青 or 無色が見つかりませんでした）'); 
    return;
  }

  // 最低1枚は残す（スプレッドシートの制約）
  if (deletable.length >= all.length) {
    deletable.sort((a,b)=>a.getIndex()-b.getIndex());
    const spare = deletable.shift();       // 左端の1枚を残す
    skipped.push(spare.getName());
  }

  const names = deletable.map(s=>s.getName());
  const preview = names.join(', ').slice(0, 800) + (names.join(', ').length > 800 ? ' …' : '');
  const res = ui.alert('確認',
    `以下のシートを削除します（取り消し不可）:\n${preview}\n\n実行してよろしいですか？`,
    ui.ButtonSet.YES_NO);
  if (res !== ui.Button.YES) return;

  // 削除実行
  let deleted = 0;
  for (const sh of deletable){
    try { ss.deleteSheet(sh); deleted++; }
    catch (e) { skipped.push(`${sh.getName()}（削除失敗: ${e.message}）`); }
  }

  ss.toast(`削除: ${deleted} / スキップ: ${skipped.length}`);
}

/** メニュー：シート削除 → 青＆色なしを削除 */
function buildMenu_SheetDelete_(){
  SpreadsheetApp.getUi()
    .createMenu('シート削除')
    .addItem('青＆色なしを削除（赤は残す）', 'deleteBlueAndColorlessSheets_')
    .addToUi();
}
